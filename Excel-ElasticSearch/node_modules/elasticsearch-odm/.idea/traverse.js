'use-strict';
var mocks = require('../tests/fixtures/schema-mocks'),
    app = require('../index'),
    schemaTypes = require('../lib/schema-types'),
    _ = require('lodash'),
    dot = require('dot-object');

test();

function test(){
  var s = buildMappings(mocks.nestedSingleLevel);
  console.log(s);
}


function buildMappings(fields){

  var results = {
    fields: {}
  };

  Object.keys(fields).forEach(function(v){
    mapSchemaType(v);
  });

  function mapSchemaType(key, path) {
    var value = dot.pick(path ? path + '.' + key : key, fields);;
    var schemaType;
    var typeOptions;

    if (_.isPlainObject(value)) {

      if(value.type){
        typeOptions = _.omit(value, 'type');

        if(_.isArray(value.type)){
          // mapping as an array is just a helper so it's similar to mongoose
          // elasticsearch doesn't actually care if it's defined as an array.
          schemaType = findType(value.type[0]);
        }else{
          schemaType = findType(value.type);
        }

      }else{
        // it's a nested document, recursively map it too add add to currentPath
        Object.keys(value).forEach(function(v){
          mapSchemaType(v, key);
        });
      }

    }else if(_.isFunction(value)) {
      schemaType = findType(value);
    }else if(_.isArray(value)){
      schemaType = findType(value[0]);
    }else if(_.isString(value)){
      schemaType = findType(value);
    }else{
      schemaType = findType(value);
    }

    if(schemaType) {
      // if we found a schema type, add it to the results.
      // below is just an easy way to inject into object by dot notation
      var newSchema = new schemaType(typeOptions);
     // console.log(key);
      dot.str(path ? path + '.' + key : key, {
        type: newSchema,
        mapping: newSchema.toMapping()
      }, results.fields);
    }
  }

  return results;
}

function findType(item){
  var sType;
  _.forOwn(schemaTypes, function(v, k){
    if(item === v.jsType || item === v.esType) sType = v;
  });
  return sType;
}
